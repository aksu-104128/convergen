Convergen
=========

A type-to-type copy function code generator.

Notation Table
--------------

| notation                                          | location         | summary                                                                  |
|---------------------------------------------------|------------------|--------------------------------------------------------------------------|
| :convergen                                        | interface        | Mark the interface as a converter definition.                            |
| :style &lt;`return` &#124; `arg`>                 | interface,method | Set the style of the assignee variable input/output (default: `return`). |
| :match &lt;`name` &#124; `none`>                  | interface,method | Set the field matcher algorithm (default: `name`).                       |
| :case                                             | interface,method | Set case-sensitive for name match (default).                             |
| :case:off                                         | interface,method | Set case-insensitive for name match.                                     |
| :getter                                           | interface,method | Include getters for name match.                                          |
| :getter:off                                       | interface,method | Exclude getters for name match (default).                                |
| :stringer                                         | interface,method | Call String() if appropriate in name match.                              |
| :stringer:off                                     | interface,method | Call String() if appropriate in name match (default).                    |
| :typecast                                         | interface,method | Allow type casting if appropriate in name match.                         |
| :typecast:off                                     | interface,method | Suppress type casting if appropriate in name match (default).            |
| :recv &lt;_var_>                                  | method           | Specify the source value as a receiver of the generated function.        |
| :reverse                                          | method           | Reverse copy direction. Might be useful with receiver form.              |
| :skip &lt;_dst field_>                            | method           | Specify field(s) to omit.                                                |
| :map &lt;_src field_> &lt;_dst field_>            | method           | Specify field mapping rule.                                              |
| :conv &lt;_func_> &lt;_src field_> [_to field_]   | method           | Specify a converter for field(s).                                        |
| :postprocess &lt;_func_>                          | method           | Specify a post-process func.                                             |

Sample
------

Generates function(s) that copy field to field between two types.

Write a generator code in a convention:

```go
//go:build convergen

package sample

import (
    "time"

    "github.com/sample/myapp/domain"
    "github.com/sample/myapp/storage"
)

//go:generate go run github.com/reedom/convergen
type Convergen interface {
    // :typecast
    // :stringer
    // :map Created.UnixMilli() Created
    DomainToStorage(*domain.User) *storage.User
}
```

*covergen* will generate:

```go
// Code generated by github.com/reedom/convergen
// DO NOT EDIT.

package sample

import (
    "time"

    "github.com/sample/myapp/domain"
    "github.com/sample/myapp/storage"
)

func DomainToStorage(src *domain.User) (dst *storage.User) {
    dst = &storage.User{}
    dst.ID = int64(src.ID)
    dst.Name = src.Name
    dst.Status = src.Status.String()
    dst.Created = src.Created.UnixMilli()

    return
}
```

for these struct types:

```go
package domain

import (
    "time"
)

type User struct {
    ID      int
    Name    string
    Status  Status
    Created time.Time
}

type Status string

func (s Status) String() string {
    return string(s)
}
```

```go
package storage

type User struct {
    ID      int64
    Name    string
    Status  string
    Created int64
}
```

Installation and intro
----------------------

### Use as a Go generator

At under your Go project directory, install the module via `go get`:

```shell
$ go get -u github.com/reedom/convergen@latest
```

then write a generator as:

```go
//go:generate go run github.com/reedom/convergen
type Convergen interface {
    …
}
````

### Use as a CLI command

Install the command via `go install`:

```shell
$ go install github.com/reedom/convergen
```

then you can generate code by calling:

```shell
$ convergen any-codegen-defined-code.go
```

CLI help shows:

```shell
Usage: convergen [flags] <input path>

By default, the generated code is written to <input path>.gen.go

Flags:
  -dry
        dry run
  -log
        write log to <output path>.log
  -out string
        output file path
  -print
        print result code to STDOUT as well
```

Notations
---------

### `:convergen`

Mark the interface as a converter definition.

By default, Convergen look for only an interface named "Convergen" as a converter definition block.
By marking with `:convergen` notation, let Convergen recognize them. This is useful especially if you want
to define same name methods but having different receivers.

__Available locations__

interface

__Format__

```text
":convergen"
```

__Examples__

```go
// :convergen
type TransportConvergen struct {
    // :recv t
    ToDomain(*trans.Model) *domain.Model 
}

// :convergen
type PersistentConvergen struct {
    // :recv t
    ToDomain(*persistent.Model) *domain.Model 
}

```


### `:style <style>`

Set the style of the assignee variable input/output.

__Default__

`:style return`

__Available locations__

interface, method

__Format__

```text
":style" style

style = "arg" | "return"
```

__Examples__

Examples of `return` style.

basic:

```go
func ToStorage(src *domain.Pet) (dst *storage.Pet) {
```

with error:

```go
func ToStorage(src *domain.Pet) (dst *storage.Pet, err error) {
```

with receiver:

```go
func (src *domain.Pet) ToStorage() (dst *storage.Pet) {
```

Examples of `arg` style.

basic:

```go
func ToStorage(dst *storage.Pet, src *domain.Pet) {
```

with error:

```go
func ToStorage(dst *storage.Pet, src *domain.Pet) (err error) {
```

with receiver:

```go
func (src *domain.Pet) ToStorage(dst *storage.Pet) {
```

### `:match <algorithm>`

Set the field matcher algorithm.

__Default__

`:match name`

__Available locations__

interface,method

__Format__

```text
":match" <algorithm>

algorithm = "name" | none"
```

__Examples__

With `name` match, the generator matches up with fields or getters names (and their types).

```go
package model

type User struct {
  ID   int
  Name string
}
```
```go
package web

type User struct {
  id   int
  name string
}

func (u *User) ID() int {
  return u.id
}
```
```go
// :match name 
type Convergen interface {
  ToStorage(*User) *storage.User
}
```

Convergen generates:

```go
func ToStorage(src *User) (dst *storage.User) {
  dst := &storage.User{}
  dst.ID = src.ID()
  dst.Name = src.name
  
  return
}
```

With `none` match, it only processes explicitly specified fields or getters via `:map` and `:conv`. 

### `:case` / `:case:off`

Control case-sensitive match or case-insensitive match.

The notification takes effect in `:match name`, `:getter` and `:skip`.  
Other notations, namely `:map`, `:conv`, keep case-sensitive match.

__Default__

":case"

__Available locations__

interface, method

__Format__

```go
":case"
":case:off"
```

__Examples__

// interface level notation makes ":case:off" as default.
// :case:off
type Convergen struct {
    // Turn on case-sensitive match for names.
    // :case
    ToUserModel(*domain.User) storage.User

    // Adopt the default, case-insensitive match in this case.
    ToCategoryModel(*domain.Category) storage.Category
}

### `:getter` / `:getter:off`

Include getters for name match.

__Default__

`:getter:off`

__Available locations__

interface, method

__Format__

```text
":getter"
":getter:off"
```

__Examples__

With those models:

```go
package domain

type User struct {
    name string
}

func (u *User) Name() string {
    return u.name
}
```

```go
package storage

type User struct {
    Name string
}
```

The default Convergen behaviour can't find the private `name` and won't notice the getter.  
So, with the following we'll get…

```go
type Convergen struct {
    ToStorageUser(*domain.User) *storage.User
}
````

```go
func ToStorageUser(src *domain.User) (dst *storage.User)
    dst = &storage.User{}
	  // no match: dst.Name

    return
}
```

And with `:getter` we'll have…

```go
type Convergen struct {
    // :getter
    ToStorageUser(*domain.User) *storage.User
}
````

```go
func ToStorageUser(src *domain.User) (dst *storage.User)
    dst = &storage.User{}
	  dst.Name = src.Name()

    return
}
```

Alternatively, you can get the same result with `:map`.  
This is worth to learn since `:getter` affects the entire method - `:map` allows you to get
the result selectively. 

```go
type Convergen struct {
    // :map Name() Name
    ToStorageUser(*domain.User) *storage.User
}
```

### `:stringer` / `:stringer:off`

Call String() if appropriate in name match.

__Default__

`:stringer:off`

__Available locations__

interface, method

__Format__

```text
":stringer"
":stringer:off"
```

__Examples__

With those models:

```go
package domain

type User struct {
    Status Status
}

type Status struct {
    status string
}

func (s Status) String() string {
    return string(s)
}

var (
    NotVerified = Status{"notVerified"}
    Verified    = Status{"verified"}
    Invalidated = Status{"invalidated"}
)
```

```go
package storage

type User struct {
    String string
}
```

For `status` field, Convergen has no idea how to assign `Status` type to `string` by default.  
Letting it to lookup `String()` methods by chance, it will employ while the method is appropriate to the assignee. 

```go
type Convergen struct {
    // :stringer
    ToStorageUser(*domain.User) *storage.User
}
````

```go
func ToStorageUser(src *domain.User) (dst *storage.User)
    dst = &storage.User{}
	  dst.Status = src.Status.String()

    return
}
```

Alternatively, you can get the same result with `:map`.  
This is worth to learn since `:stringer` affects the entire method - `:map` allows you to get
the result selectively.

```go
type Convergen struct {
    // :map Status.String() Name
    ToStorageUser(*domain.User) *storage.User
}
```

### `:typecast`

Allow type casting if appropriate in name match.

__Default__

`:typecast:off`

__Available locations__

interface, method

__Format__

```text
":typecast"
":typecast:off"
```

__Examples__

With those models:

```go
package domain

type User struct {
    ID     int
    Name   string
    Status Status
}

type Status string

```

```go
package storage

type User struct {
    ID     int64	
    Name   string
    Status string
}
```

Convergen respect types strictly. So that it will give up copying fields if their types does not match.  
To note, Convergen relies on [types.AssignableTo(V, T Type) bool](https://pkg.go.dev/go/types#AssignableTo) method
from the standard packages. It means that the judge is done by the type system of Go itself, not by a dumb string type name match. 

Without `:typecast` turning on…
```go
type Convergen struct {
    ToDomainUser(*storage.User) *domain.User
}
````

We'll get:

```go
func ToDomainUser(src *storage.User) (dst *domain.User)
    dst = &domain.User{}
    // no match: dst.ID
    dst.Name = src.Name
    // no match: dst.Status

    return
}
```

With `:typecast` it turns to:

```go
func ToDomainUser(src *storage.User) (dst *domain.User)
    dst = &domain.User{}
	  dst.ID = int(src.ID)
    dst.Name = src.Name
    dst.Status = domain.Status(src.Status)

    return
}
```

### `:convergen`

Mark the interface as a converter definition.

__Default__

__Available locations__

interface, method

__Format__

```text
":convergen"
```

__Examples__

TBD

Contributing
------------

I highly appreciate any kind of contributions!

Like:

- Report bugs.
- Report a use case that the current implementation seems not fulfill. 
- implement new features by making a pull-request.
- Add or improve the document or examples.
- Create a project's logo.
