# 1. 简单使用

假设有 model

> 两个model可以在 **`不同的package`**

``` go
package main

type A struct {
	A int
	B string
	C float32
}

type B struct {
	A int
	B string
	C float32
}
```

编写模板如下(`convergen.go`, **文件名随意**)
``` go
//go:build convergen

package main

type Convergen interface {
	A2B(*A) *B
	B2A(A) B
}
```

运行命令 `./build/convergen convergen.go`


生成的代码如下 (`convergen.gen.go`)
``` go
// Code generated by github.com/reedom/convergen
// DO NOT EDIT.

package main

func A2B(src *A) (dst *B) {
	if src == nil {
		return
	}

	dst = &B{}
	dst.A = src.A
	dst.B = src.B
	dst.C = src.C

	return
}

func B2A(src A) (dst B) {
	dst.A = src.A
	dst.B = src.B
	dst.C = src.C

	return
}
```

## 1.2. 输出路径
缺省会基于模板文件名后缀前面加上 **`.gen`**

**选项**
+ **`out`**: 指定完整路径 `convergen -out=ab.conv.go convergen.go` 生成文件 `ab.conv.go`
+ **`suffix`**: 指定后缀 `convergen -suffix=transfer convergen.go` 生成文件 `convergen.transfer.go`

## 1.3. 输入
缺省通过参数指定输入文件名, 如果未指定, 会尝试从环境变量 [$GOFILE](https://pkg.go.dev/cmd/go#hdr-Generate_Go_files_by_processing_source) 获得

所以使用 `go generate` 时, 并不需要指定输入文件名

``` go
package main

//go:generate convergen
```

# 2. 模板 interface
前面的例子包含一个名称为 **`Convergen`** 的 **interface**, 所有生成的转换函数, 都在该interface定义

> 缺省情况下, 名称固定为 `Convergen`

也可以通过注释 `// :convergen` 来声明, 例如
``` go
// :convergen
type AnotherConvergen interface {
	A2B(*A) *B
	B2A2(A) B
}
```

或者多个

``` go
//go:build convergen

package main

type Convergen interface {
	A2B(*A) *B
}

// :convergen
type AnotherConvergen interface {
	B2A2(A) B
}
```

# 3. 注解

前面的例子中, 字段的名称和类型都完全一样, 所以很轻松地完成了代码的生成

一些特殊情况, 就需要通过**注解**来辅助代码生成

## 3.2. case
比较字段名忽略大小写, 缺省禁用

> 本选项对 **`所有field`** 生效

例如字段Aa, 另一边字段是AA, 会匹配不到

``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	// no match: dst.AA
```

添加注释 **`// :case:off`** 后, 会自动忽略大小写差异
``` go
type Convergen interface {
	// :case:off
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.AA = src.Aa
}
```

+ **`// :case:off`** 忽略大小写
+ **`// :case`** 启用大小写敏感比较

## 3.3. typecase
自动尝试类型强制转换, 缺省禁用

> 本选项对 **`所有field`** 生效

例如 字段A一边是 **int**, 另一边是 **int32**, 会匹配不到,  生成的代码会有 **`no match`**
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	// no match: dst.A
}
```

添加注释 **`// :typecast`** 后, 会自动类型转换
``` go
type Convergen interface {
	// :typecast
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = int(src.A)
}
```

+ **`// :typecast:off`** 关闭自动类型转换
+ **`// :typecast`** 开启自动类型转换

如果是 int 和 string, 会生成如下 **`问题代码`**

``` go
	dst = &B{}
	dst.A = string(src.A)
```


## 3.4. getter
如果源struct有同名的 **成员方法**, 那么自动调用方法, 缺省禁用

> 本选项对 **`所有field`** 生效

``` go
type A struct {
	a int
	B string
	C float32
}

func (a *A) A() string {
	return strconv.Itoa(a.a)
}

type B struct {
	A string
	B string
	C float32
}
```

添加注释 **`// :getter`** 后, 会自动调用同名函数
``` go
type Convergen interface {
	// :getter
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.A()
}
```

+ **`// :getter`** 忽略大小写
+ **`// :getter:off`** 启用大小写敏感比较

## 3.5. stringer
如果源field是结构且存在 **`String()方法`**, 目标field是字符串, 那么会尝试调用结构的String() 函数

> 可以和 **`getter`** 配合使用

``` go
import "strconv"

type SubObj struct {
	A int
}

func (so SubObj) String() string {
	return strconv.Itoa(so.A)
}

type LocalStr string

func (s LocalStr) String() string {
	return string(s)
}

type A struct {
	A LocalStr // 别名
	B *SubObj  // 对象
	c SubObj   // stringer / getter 配合使用
}

func (a *A) C() *SubObj {
	return &a.c
}

type B struct {
	A string
	B string
	C string
}
```
``` go
type Convergen interface {
	// :stringer
	// :getter
	A2B(*A) *B
}
```
生成代码
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.A.String()
	dst.B = src.B.String()
	dst.C = src.C().String()
}
```

## 3.6. conv
对源字段调用某个函数, 再返回目标字段的类型

``` go
import "strconv"

// 为了让go添加import strconv, 并不需要实际使用 Itoa
var Itoa = strconv.Itoa

type Convergen interface {
	// :conv strconv.Itoa A
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = strconv.Itoa(src.A)
}
```

如果两边字段类型不一致, 支持同时`字段映射`

> conv 第二/三参数的顺序 和 接口函数的 输入/输出 顺序一致

``` go
type Convergen interface {
	// :conv strconv.Itoa AA Aa
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.Aa = strconv.Itoa(src.AA)
}
```

也可以和 stringer 配合使用

``` go
type LocalStr string

func (s LocalStr) String() string {
	return string(s)
}

type A struct {
	a LocalStr
}

type B struct {
	A string
}
```
``` go
type Convergen interface {
	// :stringer
	// :conv strings.ToLower a A
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = strings.ToLower(src.a.String())
}
```


## 3.7 method
赋值的时候自动调用源字段的某个成员函数

> method 第二/三参数的顺序 和 接口函数的 输入/输出 顺序一致
> 
``` go
type A struct {
	A time.Time
	c time.Time
}

type B struct {
	A time.Time
	C string
}
```

字段C 自动做了字段映射

``` go
type Convergen interface {
	// :method Local A
	// :method String c C
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.A.Local()
	dst.C = src.c.String()
}
```

> 针对错误处理, 另有扩展 **`:method:err`**, 见后续说明

## 3.8 skip
某些字段不需要处理, 可以明确的忽略它

``` go
type Convergen interface {
	// :skip A
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	// skip: dst.A
	dst.B = src.B
	dst.C = src.C
}
```

## 3.9 map
仅仅字段名有区别, 可以用map做映射

> map 第一/二参数的顺序 和 接口函数的 输入/输出 顺序一致

``` go
type Convergen interface {
	// :map a A
	A2B(*A) *B
}
```

这个情况比较特殊, 可以用 `:case` 简单处理, 但是一些复杂情况就不行了

``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.a
}
```

map 可以配合 **stringer** **`或者`** **typecast** 使用

``` go
type LocalStr string
type LocalStr2 string

func (s LocalStr) String() string {
	return string(s)
}

type A struct {
	a LocalStr
	b string
}

type B struct {
	A string
	B LocalStr2
}
```
``` go
type Convergen interface {
	// :map a A
	// :map b B
	// :stringer
	// :typecast
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.a.String()
	dst.B = LocalStr2(src.b)
	dst.C = src.C
}
```

## 3.10 literal

不关注源数据, 直接赋值

``` go
const XStr = "xx"

type A struct{}

type B struct {
	A string
	B int
	C float32
	D string
	E time.Time
}
```
``` go
type Convergen interface {
	// :literal A "aaaa"
	// :literal B 123
	// :literal C 3.1415
	// :literal D XStr
	// :literal E time.Now()
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = "aaaa"
	dst.B = 123
	dst.C = 3.1415
	dst.D = XStr
	dst.E = time.Now()
}
```

# 4 递归赋值

``` go
type SubA struct {
	SA string
	SB int
}

type SubB struct {
	SA string
	SB int
}

type A struct {
	A string
	B SubA // 如果用指针, 有问题, 所以很鸡肋
}

type B struct {
	A string
	B SubB
}
```
``` go
type Convergen interface {
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.A
	dst.B.SA = src.B.SA
	dst.B.SB = src.B.SB
}
```

最好的做法是, 每个struct自己转自己的
``` go
type A struct {
	A string
	B *SubA // 改成指针
}

type B struct {
	A string
	B *SubB
}
```

加转换函数
``` go
type Convergen interface {
	// :conv SubA2B B
	A2B(*A) *B
	SubA2B(*SubA) *SubB
}
```

生成多个函数, 各司其职
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	dst.A = src.A
	dst.B = SubA2B(src.B)
}

func SubA2B(src *SubA) (dst *SubB) {
	dst = &SubB{}
	dst.SA = src.SA
	dst.SB = src.SB
}
```

# 5. 数组

如果是基本类型, 可以直接生成代码
``` go
type A struct {
	A []string
}

type B struct {
	A []string
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	if src.A != nil {
		dst.A = make([]string, len(src.A))
		copy(dst.A, src.A)
	}
}
```

## 5.2. 对象数组
不同的对象没办法直接转换, 所以需要借助 conv 或者 method

``` go
type SubA struct {
	SA string
	SB int
}

// 有成员函数用来转换
func (sa *SubA) ToB() *SubB {
	return nil
}

type SubB struct {
	SA string
	SB int
}

type A struct {
	A []*SubA
	B []*SubA
}

type B struct {
	A []*SubB
	B []*SubB
}
```

> 注意后面的 **`中括号`**
> 
> **`不`** 支持 **字段映射**

``` go
type Convergen interface {
	// :conv SubA2B A[]
	// :method ToB B[]
	A2B(*A) *B
	SubA2B(*SubA) *SubB
}
```
``` go

func A2B(src *A) (dst *B) {
	dst = &B{}
	if src.A != nil {
		dst.A = make([]*SubB, len(src.A))
		for i, e := range src.A {
			dst.A[i] = SubA2B(e)
		}
	}
	if src.B != nil {
		dst.B = make([]*SubB, len(src.B))
		for i, e := range src.B {
			if e != nil {
				dst.B[i] = e.ToB()
			}
		}
	}
}
```

# 6. 成员函数
`// :recv` 用来声明, 生成成员函数,而不是独立函数

回到上面的例子, 需要手动编码函数 `func (sa *SubA) ToB() *SubB`

也可以自动生成

``` go
type Convergen interface {
	// :conv SubA2B A[]
	// :method ToB B[]
	A2B(*A) *B
	SubA2B(*SubA) *SubB
	// :recv s
	ToB(*SubA) *SubB
}
```

> recv 的一个参数是成员函数的this变量的名称

如果有多个对象需要生成同名的成员函数, 由于interface的方法不能重名, 所以可以通过 **`:recv`** 的第二个参数来 **trim prefix**

``` go
type Convergen interface {
	// :conv SubA2B A[]
	// :method ToB B[]
	A2B(*A) *B
	SubA2B(*SubA) *SubB
	// :recv s SubA
	SubAToB(*SubA) *SubB
}
```

**`// :recv s SubA`** 会自动把生成的成员函数名 `SubAToB` 去掉前缀 SubA, 变成 `ToB`

# 7. 前置后置处理
对于通过规则也无法处理的赋值, 可以用自定义函数, 分为
1. **`// :preprocess`** 前置处理
2. **`// :postprocess`** 后置处理

``` go
func TransferProcess(b *B, a *A) {}

type A struct {
	A string
	B string
}

type B struct {
	A string
	B string
}
```
``` go
type Convergen interface {
	// :preprocess TransferProcess
	// :postprocess TransferProcess
	A2B(*A) *B
}
```
``` go
func A2B(src *A) (dst *B) {
	dst = &B{}
	TransferProcess(dst, src)
	dst.A = src.A
	dst.B = src.B
	TransferProcess(dst, src)
}
```

> 理论上用这个自定义函数可以完成所有的自定义能力, 但是不优雅

# 8. 错误返回
下列函数, 除了返回目标对象外, 还可以增加 error
+ **`:preprocess`** 
+ **`:postprocess`**
+ **`:conv`**
+ **`:method:err`**

此时如果某个转换函数用到了这些函数, 也需要增加 error 返回值

``` go
func TransferProcess(b *B, a *A) error {
	return nil
}

func FieldConv(a string) (LocalStr, error) {
	return "", nil
}

type LocalStr string

func (s LocalStr) ToX() (string, error) {
	return string(s), nil
}

type A struct {
	A     string
	AList []string
	B     LocalStr
	BList []LocalStr
}

type B struct {
	A     LocalStr
	AList []LocalStr
	B     string
	BList []string
}
```
``` go
type Convergen interface {
	// :preprocess TransferProcess
	// :postprocess TransferProcess
	// :conv FieldConv A
	// :conv FieldConv AList[]
	// :method:err ToX B
	// :method:err ToX BList[]
	A2B(*A) (*B, error)
}
```
``` go
func A2B(src *A) (dst *B, err error) {
	if src == nil {
		return
	}

	dst = &B{}
	err = TransferProcess(dst, src)
	if err != nil {
		return
	}
	dst.A, err = FieldConv(src.A)
	if err != nil {
		return nil, err
	}
	if src.AList != nil {
		dst.AList = make([]LocalStr, len(src.AList))
		for i, e := range src.AList {
			dst.AList[i], err = FieldConv(e)
			if err != nil {
				return nil, err
			}
		}
	}
	dst.B, err = src.B.ToX()
	if err != nil {
		return nil, err
	}
	if src.BList != nil {
		dst.BList = make([]string, len(src.BList))
		for i, e := range src.BList {
			dst.BList[i], err = e.ToX()
			if err != nil {
				return nil, err
			}
		}
	}
	err = TransferProcess(dst, src)
	if err != nil {
		return
	}

	return
}
```

对于 **`:conv`**, convergen会先尝试查找现有代码, 如果找不到会尝试找`生成的代码`

而 **`:method`** 由于存在 trimPrefix的特性, 且实际使用基本都属于这种, 要从生成的代码中找到符号, 实现非常复杂, 所以这里对 **`:method`** 扩展, 增加 **`:method:err`**, 后者假定代码原型有error返回值

# 9. 配置继承
convergen配置有三层

+ 命令行参数
+ convergen interface 注解
+ convergen interface func 注解

优先级依次提高, 如果后者未声明, 就从上层继承

## 9.2. 命令行参数

> 全局有效

支持以下选项

+ case
+ cast
+ stringer
+ getter

## 9.3. convergen interface

> 对该interface的所有func有效

支持以下选项

+ style, 见后面说明
+ case
+ case:off
+ getter
+ getter:off
+ stringer
+ stringer:off
+ typecast
+ typecast:off
+ skip

## 9.3. convergen interface func

> 对该interface的单个func有效

支持以下选项

+ style, 见后面说明
+ reverse, 见后面说明
+ case
+ case:off
+ getter
+ getter:off
+ stringer
+ stringer:off
+ typecast
+ typecast:off
+ skip
+ recv       
+ map       
+ conv  
+ method
+ method:err
+ literal
+ preprocess
+ postprocess

# 10. 其他
## 10.1. style

style 默认 **`return`**, 表示结果通过return值返回

可选 **`arg`**, 结果通过参数指针返回, 例如上面的例子

``` go
// :style arg
type Convergen interface
```

生成的结果, 通过参数返回

``` go
func A2B(dst *B, src *A) (err error)
```

## 10.2. reverse

缺省情况下, convergen interface的函数参数是**输入**, 返回值是**输出**

``` go
type Convergen interface {
	// 从输入A 转换成B
	A2B(*A) (*B, error)
}
```

如果是 **`:recv`**, 那相当于 `A.A2B() -> *B`, 如果想从 B 赋值到A自己, 就需要 **`:reverse`**

``` go
// :recv r
// :reverse
// :style arg
RevRcvFromArgVal(*Pet) model.Pet
```

下面的代码, 从原型返回值 (这通常需要配合使用 **`:style arg`**) 初始化自己

``` go
func (r *Pet) RevRcvFromArgVal(src *model.Pet) {
	r.ID = src.ID
	r.Category = src.Category
	r.Name = src.Name
	if src.PhotoUrls != nil {
		r.PhotoUrls = make([]string, len(src.PhotoUrls))
		copy(r.PhotoUrls, src.PhotoUrls)
	}
	r.Status = src.Status
}
```